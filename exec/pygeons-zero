#!/usr/bin/env python
import argparse
import json
import sys
import os
import shutil
import pygeons.ioconv
import pygeons.interface
import logging

def get_extension(f):
  return f.split('.')[-1]
  
def change_extension(f,ext):
  return '.'.join(f.split('.')[:-1] + [ext])
    

p = argparse.ArgumentParser(
  description='''Estimates and removes the displacements at the 
                 indicated time. The offset is calculated with a 
                 weighted mean centered about the *zero_time*. 
                 *radius* specifies the temporal extent of data used 
                 in the weighted mean''')                 
p.add_argument('input_file',type=str,
               help='''Input date file. Can either be a PBO csv file, a PBO 
                       pos file, or a HDF5 file. The file type is 
                       inferred from its extension. ".hdf", ".h5", 
                       ".hdf5", ".he5" are interpretted as HDF5, 
                       ".pos" is interpretted as PBO pos, anything 
                       else is assumed to be a PBO csv file.''')                       
p.add_argument('zero_date',type=str,
               help='''Zero displacements at this date which is specified 
                       in YYYY-MM-DD''')
p.add_argument('radius',type=int,
               help='''number of days before and after *zero_time* to 
                       use when calculating the offset''')
p.add_argument('--output_file',type=str,
               help='''If not provided then the input file extension 
                       is removed and replaced with smooth.h5. The
                       output file type is inferred from the 
                       extension. Currently, can only output to HDF5 
                       files or PBO csv files.''')
p.add_argument('-v','--verbose',action='count',default=0,
               help='''Controls verbosity''')
p.add_argument('--cut_dates',nargs='+',type=str,
               help='''list of time discontinuities in YYYY-MM-DD. 
                       This date should be when the discontinuity is 
                       first observed''')
               
p = vars(p.parse_args())

# set logger
verbose = p.pop('verbose')
if verbose == 0:
  logging.basicConfig(level=logging.WARNING)
elif verbose == 1:
  logging.basicConfig(level=logging.INFO)
else:
  logging.basicConfig(level=logging.DEBUG)

input_file = p.pop('input_file')
output_file = p.pop('output_file')

# throw out any Nones and let the lower level functions determine the defaults
for k in p.keys():
  if p[k] is None:
    p.pop(k)

if output_file is None:
  output_file = change_extension(input_file,'zero.h5')

data_dict = pygeons.ioconv.dict_from_file(input_file)
out_dict = pygeons.interface.zero(data_dict,**p)
pygeons.ioconv.file_from_dict(output_file,out_dict)

# check to see if there is an associated pert directory
input_pert_dir = input_file+'.pert'
if os.path.exists(input_pert_dir):
  input_ext = get_extension(input_file)
  output_ext = get_extension(output_file)
  output_pert_dir = output_file+'.pert'
  # make output perturbation directory
  if os.path.exists(output_pert_dir):
    shutil.rmtree(output_pert_dir)

  os.mkdir(output_pert_dir)
  input_pert_files = os.listdir(input_pert_dir)
  # output pert files have the same name but with the appropriate 
  # extension
  output_pert_files = [change_extension(i,output_ext) for i in input_pert_files]

  input_pert_paths = [input_pert_dir+'/'+f for f in input_pert_files]
  output_pert_paths = [output_pert_dir+'/'+f for f in output_pert_files]

  for fin,fout in zip(input_pert_paths,output_pert_paths):
    data_dict = pygeons.ioconv.dict_from_file(fin)
    out_dict = pygeons.interface.zero(data_dict,**p)
    pygeons.ioconv.file_from_dict(fout,out_dict)

