#!/usr/bin/env python
import argparse
import json
import sys
import os
import pygeons.ioconv
import pygeons.interface
import logging

p = argparse.ArgumentParser()
p.add_argument('input_file',type=str,
               help='''date file. Can either be a PBO csv file, a PBO 
                       pos file, or a HDF5 file. The file type is 
                       inferred from the extension. ".hdf", ".h5", 
                       ".hdf5", ".he5" are interpretted as HDF5, 
                       ".pos" is interpretted as PBO pos, anything 
                       else is assumed to be a PBO csv file.''')
p.add_argument('--output_file',type=str,
               help='''if not provided then the input file extension 
                       is removed and replaced with smooth.h5. The 
                       output file type is inferred from the 
                       extension. Currently, can only output to HDF5 
                       files or PBO csv files.''')
p.add_argument('-v','--verbose',action='count',default=0,
               help='''controls verbosity''')
p.add_argument('--color_cycle',nargs='+',type=str)
p.add_argument('--resolution',type=str)               
p.add_argument('--quiver_key_label',type=str)
p.add_argument('--quiver_key_length',type=float)
p.add_argument('--quiver_scale',type=float)
p.add_argument('--quiver_width',type=float)
p.add_argument('--quiver_key_pos',nargs=2,type=float)
p.add_argument('--scatter_show',type=bool)
p.add_argument('--scatter_size',type=float)
p.add_argument('--image_clim',nargs=2,type=float)
p.add_argument('--image_cmap',type=str)
p.add_argument('--image_array_size',type=int)
p.add_argument('--image_clabel',type=str)
p.add_argument('--ts_xlabel',type=str)
p.add_argument('--ts_ylabel_0',type=str)
p.add_argument('--ts_ylabel_1',type=str)
p.add_argument('--ts_ylabel_2',type=str)
p.add_argument('--ts_title',type=str)
p.add_argument('--map_title',type=str)
p.add_argument('--map_xlim',nargs=2,type=float)
p.add_argument('--map_ylim',nargs=2,type=float)
p.add_argument('--fontsize',type=float)
p.add_argument('--cut_endpoint1_lons',nargs='+',type=float)
p.add_argument('--cut_endpoint1_lats',nargs='+',type=float)
p.add_argument('--cut_endpoint2_lons',nargs='+',type=float)
p.add_argument('--cut_endpoint2_lats',nargs='+',type=float)
               
p = vars(p.parse_args())

# set logger
verbose = p.pop('verbose')
if verbose == 0:
  logging.basicConfig(level=logging.WARNING)
elif verbose == 1:
  logging.basicConfig(level=logging.INFO)
else:
  logging.basicConfig(level=logging.DEBUG)

input_file = p.pop('input_file')
output_file = p.pop('output_file')

# throw out any Nones and let the lower level functions determine the defaults
for k in p.keys(): 
  if p[k] is None: 
    p.pop(k)

if output_file is None:
  input_file_split = input_file.split('.')
  output_file_split = input_file_split[:-1] + ['clean.h5']
  output_file = '.'.join(output_file_split)

data_dict = pygeons.ioconv.dict_from_file(input_file) 
out_dict = pygeons.interface.clean(data_dict,**p)
pygeons.ioconv.file_from_dict(output_file,out_dict)

# check to see if there is an associated pert directory
input_pert_dir = '.'.join(input_file.split('.')[:-1] + ['pert'])
output_pert_dir = '.'.join(output_file.split('.')[:-1] + ['pert'])

if os.path.exists(input_pert_dir):
  # make output perturbation directory
  if not os.path.exists(output_pert_dir):
    os.mkdir(output_pert_dir)
    
  input_pert_files = os.listdir(input_pert_dir)
  input_pert_paths = ['/'.join([input_pert_dir,f]) for f in input_pert_files]
  output_pert_paths = ['/'.join([output_pert_dir,f]) for f in input_pert_files]

  for fin,fout in zip(input_pert_paths,output_pert_paths):
    data_dict = pygeons.ioconv.dict_from_file(fin)
    out_dict = pygeons.interface.clean(data_dict,**p)
    pygeons.ioconv.file_from_dict(fout,out_dict)

